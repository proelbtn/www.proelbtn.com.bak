<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="https://www.proelbtn.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.proelbtn.com/" rel="alternate" type="text/html" /><updated>2020-04-11T04:49:40-05:00</updated><id>https://www.proelbtn.com/feed.xml</id><title type="html">proelbtn’s page</title><subtitle></subtitle><entry><title type="html">WireGuardを利用した時のMTUについて</title><link href="https://www.proelbtn.com/network/wireguard/2020/04/11/wireguard-mtu.html" rel="alternate" type="text/html" title="WireGuardを利用した時のMTUについて" /><published>2020-04-11T00:00:00-05:00</published><updated>2020-04-11T00:00:00-05:00</updated><id>https://www.proelbtn.com/network/wireguard/2020/04/11/wireguard-mtu</id><content type="html" xml:base="https://www.proelbtn.com/network/wireguard/2020/04/11/wireguard-mtu.html">&lt;p&gt;2019年に登場した次世代のVPNとしてWireGuardというVPNがある。L3VPNしか張れないという制約はあるものの、Linuxの実装は4000行以下で済むほどシンプルなVPNである。そのシンプルさとは裏腹に、OpenVPNやIPsecと比べて高いスループットを実現している（&lt;a href=&quot;https://www.wireguard.com/papers/wireguard.pdf&quot;&gt;Whitepaper&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;WireGuard自体のセットアップは非常に簡単だが、MTUの計算周りで少し躓いた。あまりこの部分にたいしても言及されていないため、メモとして残しておく。&lt;/p&gt;

&lt;h2 id=&quot;encapsされた後のパケット構造&quot;&gt;encapsされた後のパケット構造&lt;/h2&gt;

&lt;p&gt;WireGuardはUDP上で動くVPNである。そのため、あるパケットがencapsされると次のようなパケットの構造になる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wireguard/encaped-packet.png&quot; alt=&quot;encaped-packet.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;元々のMTUが1500bytesだとすると、IPヘッダとUDPヘッダはそれぞれ20bytes, 8bytesなのでWireGuardのパケットに割ける領域は1472bytesになる。では、実際にWireGuardによって生成されるパケットの構造を見てみる。&lt;/p&gt;

&lt;h2 id=&quot;wireguardのパケット構造&quot;&gt;WireGuardのパケット構造&lt;/h2&gt;

&lt;p&gt;WireGuardでは、以下の4種類のパケットが生成されうる。可変長なパケットは一番下のtype4だけなのでそれについて詳しく見ていく。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wireguard/type1.png&quot; alt=&quot;type1.png&quot; /&gt;
&lt;img src=&quot;/images/wireguard/type2.png&quot; alt=&quot;type2.png&quot; /&gt;
&lt;img src=&quot;/images/wireguard/type3.png&quot; alt=&quot;type3.png&quot; /&gt;
&lt;img src=&quot;/images/wireguard/type4.png&quot; alt=&quot;type4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;type4の最後にある&lt;code class=&quot;highlighter-rouge&quot;&gt;packet&lt;/code&gt;の部分が実際に暗号化されたL3パケットが入る。パケットの暗号化の流れは次のように行われる。初めに、暗号化したいパケットが16bytesの倍数になるように末尾に0をパディングする。その後、AEAD（認証付き暗号）で暗号化する。WireGuardでは、AEADの方式としてChaCha20Poly1305を利用しており、16bytesの認証用のタグが末尾につく。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wireguard/encrypt-procedure.png&quot; alt=&quot;encrypt-procedure.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ここまで分かれば適切なWireGuardのMTUが計算できる。前の節の例では、WireGuardのパケットに1472bytes割けることが分かっている。ここから&lt;code class=&quot;highlighter-rouge&quot;&gt;type&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;reserved&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;receiver&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;couter&lt;/code&gt;の分で16bytes削られ、AEADで暗号化された暗号文に1456bytes割ける。暗号文には16bytesのタグが付いているので実際の暗号文には1440bytes使える。1440bytesは16bytesの倍数なので、WireGuardデバイスのパケットサイズとして1440bytesを指定すればパケットが問題なく転送される。&lt;/p&gt;

&lt;p&gt;ここまでの計算をまとめると、WireGuardデバイスに指定すべきMTUを$y$, 元々のMTUを$x$とすると次のような関係が成り立つ。$\mathrm{floor}$は床関数（引数に与えられた小数以下の中で最も大きい整数）である。&lt;/p&gt;

&lt;p&gt;\[
    y = 16 \cdot \mathrm{floor}\left(\frac{x - 60}{16}\right)
\]&lt;/p&gt;

&lt;h2 id=&quot;実際の環境&quot;&gt;実際の環境&lt;/h2&gt;

&lt;p&gt;僕の家はソフトバンク光を契約しており、IPv4の疎通性を提供するためにIPv4 over IPv6をしている。そのため、インターネットに出ていくIPv4のMTUは1500 - 40（IPv6ヘッダのパケット長）で1460bytesである。先程の関係式の$x$に1460を代入して計算を行うと、実際にWireGuardデバイスに対して指定すべきMTUが1392bytesだと計算が出来る。&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;WireGuardを利用してL3VPNを張る時のMTUの計算式やその計算式の根拠を示した。&lt;/p&gt;</content><author><name></name></author><summary type="html">2019年に登場した次世代のVPNとしてWireGuardというVPNがある。L3VPNしか張れないという制約はあるものの、Linuxの実装は4000行以下で済むほどシンプルなVPNである。そのシンプルさとは裏腹に、OpenVPNやIPsecと比べて高いスループットを実現している（Whitepaper）。</summary></entry></feed>