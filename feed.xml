<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="https://www.proelbtn.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.proelbtn.com/" rel="alternate" type="text/html" /><updated>2020-04-12T06:54:41-05:00</updated><id>https://www.proelbtn.com/feed.xml</id><title type="html">proelbtn’s page</title><subtitle></subtitle><entry><title type="html">NATタイプとその判定法について</title><link href="https://www.proelbtn.com/2020/04/12/nat.html" rel="alternate" type="text/html" title="NATタイプとその判定法について" /><published>2020-04-12T00:00:00-05:00</published><updated>2020-04-12T00:00:00-05:00</updated><id>https://www.proelbtn.com/2020/04/12/nat</id><content type="html" xml:base="https://www.proelbtn.com/2020/04/12/nat.html">&lt;p&gt;少しNATに関する事を調べる機会があったのでメモ。&lt;/p&gt;

&lt;h2 id=&quot;用語&quot;&gt;用語&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;internal IP address: NATされる前のIPアドレス&lt;/li&gt;
  &lt;li&gt;internal port: NATされる前のポート番号&lt;/li&gt;
  &lt;li&gt;external IP address: NATされた後のIPアドレス&lt;/li&gt;
  &lt;li&gt;external port: NATされた後のポート番号&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;natの種類&quot;&gt;NATの種類&lt;/h2&gt;

&lt;p&gt;NATにはexternal IP address, portの決定方法や、そのエンドポイントと通信が出来るホストの範囲によって4種類に大分することが出来る。&lt;/p&gt;

&lt;h3 id=&quot;full-cone&quot;&gt;Full Cone&lt;/h3&gt;

&lt;p&gt;Full Coneでは、external IP address, portがinternal IP address, portによって決定する。このようなアドレス・ポート番号選択の挙動をEIM（Endpoint Independent Mapping）&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;と呼ぶ。また、一度このポートのマッピングが決定されると、外部ネットワークのどのホストからでもそのエンドポイントを介して通信を行うことが出来る。このようなフィルタリングの挙動をEIF（Endpoint Independent Filtering）&lt;sup id=&quot;fnref:1:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;という。&lt;/p&gt;

&lt;p&gt;MNOやMVNOなどのモバイルキャリアで持ちられるCGN（Carrier Grade NAT）では、Full ConeにすることでCGN透過性が上がりP2Pでの接続が行いやすくなる事が知られている&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h3 id=&quot;restricted-cone&quot;&gt;Restricted Cone&lt;/h3&gt;

&lt;p&gt;Restricted ConeはFull Coneと同様にEIMによってアドレスやポート番号が選択される。だが、セキュリティ上の制約から、一度そのエンドポイントを介して通信が行われたIPアドレスからのみ、内部の端末と通信が行えるようなフィルタリングがなされている。このようなフィルタリングの挙動をEDF（Endpoint Dependent Filtering）&lt;sup id=&quot;fnref:1:2&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, 特にAddress-Dependent Filteringという。&lt;/p&gt;

&lt;h3 id=&quot;port-restricted-cone&quot;&gt;Port Restricted Cone&lt;/h3&gt;

&lt;p&gt;Port Restricted ConeはRestricted Coneよりも更に制約を厳しくしたものである。一度そのエンドポイントを介して通信が行われたエンドポイントからのみ、内部の端末と通信が行えるようなフィルタリングがなされている。このようなフィルタリングの挙動はAddress and Port-Dependent Filteringと呼ばれる。&lt;/p&gt;

&lt;h3 id=&quot;symmetric&quot;&gt;Symmetric&lt;/h3&gt;

&lt;p&gt;Symmetricでは、external IP address, portを決定する際に、internal IP address, port, 通信先のIP address, portを利用して決定する。このアドレス・ポート番号選択の仕組みは通信先のエンドポイントに依存しているため、EDM（Endpoint Dependent Mapping）&lt;sup id=&quot;fnref:1:3&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;と呼ばれる。&lt;/p&gt;

&lt;h2 id=&quot;natタイプの判定法&quot;&gt;NATタイプの判定法&lt;/h2&gt;

&lt;p&gt;NATタイプの判定法に関してはRFC3489に示されている&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h2 id=&quot;追記&quot;&gt;追記&lt;/h2&gt;

&lt;p&gt;EIM, EIFはプロトコルに依存しない形にも依存する形にも出来る。依存する場合、TCP SYNで(int IP, int port)と(ext IP, ext port)のマッピングが作成された時、同一のIPとportから送られてきたUDPのパケットはそのマッピングを利用してNATされ、そのマッピングに対応するフィルタリングが利用される（デフォルトの挙動）&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/rfc/rfc5128.txt&quot;&gt;https://tools.ietf.org/rfc/rfc5128.txt&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:1:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; &lt;a href=&quot;#fnref:1:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; &lt;a href=&quot;#fnref:1:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.soumu.go.jp/main_content/000352303.pdf&quot;&gt;https://www.soumu.go.jp/main_content/000352303.pdf&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc3489&quot;&gt;https://tools.ietf.org/html/rfc3489&lt;/a&gt; &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7857#section-5&quot;&gt;https://tools.ietf.org/html/rfc7857#section-5&lt;/a&gt; &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>proelbtn</name></author><category term="Network" /><category term="WireGuard" /><summary type="html">少しNATに関する事を調べる機会があったのでメモ。</summary></entry><entry><title type="html">WireGuardを利用した時のMTUについて</title><link href="https://www.proelbtn.com/2020/04/11/wireguard-mtu.html" rel="alternate" type="text/html" title="WireGuardを利用した時のMTUについて" /><published>2020-04-11T00:00:00-05:00</published><updated>2020-04-11T00:00:00-05:00</updated><id>https://www.proelbtn.com/2020/04/11/wireguard-mtu</id><content type="html" xml:base="https://www.proelbtn.com/2020/04/11/wireguard-mtu.html">&lt;p&gt;2019年に登場した次世代のVPNとしてWireGuardというVPNがある。L3VPNしか張れないという制約はあるものの、Linuxの実装は4000行以下で済むほどシンプルなVPNである。そのシンプルさとは裏腹に、OpenVPNやIPsecと比べて高いスループットを実現している（&lt;a href=&quot;https://www.wireguard.com/papers/wireguard.pdf&quot;&gt;Whitepaper&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;WireGuard自体のセットアップは非常に簡単だが、MTUの計算周りで少し躓いた。あまりこの部分にたいしても言及されていないため、メモとして残しておく。&lt;/p&gt;

&lt;h2 id=&quot;encapsされた後のパケット構造&quot;&gt;encapsされた後のパケット構造&lt;/h2&gt;

&lt;p&gt;WireGuardはUDP上で動くVPNである。そのため、あるパケットがencapsされると次のようなパケットの構造になる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wireguard/encaped-packet.png&quot; alt=&quot;encaped-packet.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;元々のMTUが1500bytesだとすると、IPヘッダとUDPヘッダはそれぞれ20bytes, 8bytesなのでWireGuardのパケットに割ける領域は1472bytesになる。では、実際にWireGuardによって生成されるパケットの構造を見てみる。&lt;/p&gt;

&lt;h2 id=&quot;wireguardのパケット構造&quot;&gt;WireGuardのパケット構造&lt;/h2&gt;

&lt;p&gt;WireGuardでは、以下の4種類のパケットが生成されうる。可変長なパケットは一番下のtype4だけなのでそれについて詳しく見ていく。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wireguard/type1.png&quot; alt=&quot;type1.png&quot; /&gt;
&lt;img src=&quot;/images/wireguard/type2.png&quot; alt=&quot;type2.png&quot; /&gt;
&lt;img src=&quot;/images/wireguard/type3.png&quot; alt=&quot;type3.png&quot; /&gt;
&lt;img src=&quot;/images/wireguard/type4.png&quot; alt=&quot;type4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;type4の最後にある&lt;code class=&quot;highlighter-rouge&quot;&gt;packet&lt;/code&gt;の部分が実際に暗号化されたL3パケットが入る。パケットの暗号化の流れは次のように行われる。初めに、暗号化したいパケットが16bytesの倍数になるように末尾に0をパディングする。その後、AEAD（認証付き暗号）で暗号化する。WireGuardでは、AEADの方式としてChaCha20Poly1305を利用しており、16bytesの認証用のタグが末尾につく。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wireguard/encrypt-procedure.png&quot; alt=&quot;encrypt-procedure.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ここまで分かれば適切なWireGuardのMTUが計算できる。前の節の例では、WireGuardのパケットに1472bytes割けることが分かっている。ここから&lt;code class=&quot;highlighter-rouge&quot;&gt;type&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;reserved&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;receiver&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;couter&lt;/code&gt;の分で16bytes削られ、AEADで暗号化された暗号文に1456bytes割ける。暗号文には16bytesのタグが付いているので実際の暗号文には1440bytes使える。1440bytesは16bytesの倍数なので、WireGuardデバイスのパケットサイズとして1440bytesを指定すればパケットが問題なく転送される。&lt;/p&gt;

&lt;p&gt;ここまでの計算をまとめると、WireGuardデバイスに指定すべきMTUを$y$, 元々のMTUを$x$とすると次のような関係が成り立つ。$\mathrm{floor}$は床関数（引数に与えられた小数以下の中で最も大きい整数）である。&lt;/p&gt;

&lt;p&gt;\[
    y = 16 \cdot \mathrm{floor}\left(\frac{x - 60}{16}\right)
\]&lt;/p&gt;

&lt;h2 id=&quot;実際の環境&quot;&gt;実際の環境&lt;/h2&gt;

&lt;p&gt;僕の家はソフトバンク光を契約しており、IPv4の疎通性を提供するためにIPv4 over IPv6をしている。そのため、インターネットに出ていくIPv4のMTUは1500 - 40（IPv6ヘッダのパケット長）で1460bytesである。先程の関係式の$x$に1460を代入して計算を行うと、実際にWireGuardデバイスに対して指定すべきMTUが1392bytesだと計算が出来る。&lt;/p&gt;

&lt;h2 id=&quot;まとめ&quot;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;WireGuardを利用してL3VPNを張る時のMTUの計算式やその計算式の根拠を示した。&lt;/p&gt;</content><author><name>proelbtn</name></author><category term="Network" /><category term="WireGuard" /><summary type="html">2019年に登場した次世代のVPNとしてWireGuardというVPNがある。L3VPNしか張れないという制約はあるものの、Linuxの実装は4000行以下で済むほどシンプルなVPNである。そのシンプルさとは裏腹に、OpenVPNやIPsecと比べて高いスループットを実現している（Whitepaper）。</summary></entry></feed>